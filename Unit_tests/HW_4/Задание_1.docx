Задание 1. Ответьте письменно на вопросы:

1)  Почему использование тестовых заглушек может быть полезным при написании модульных тестов?

2) Какой тип тестовой заглушки следует использовать, если вам нужно проверить, что метод был вызван с определенными аргументами?

3) Какой тип тестовой заглушки следует использовать, если вам просто нужно вернуть определенное значение или исключение в ответ на вызов метода?

4) Какой тип тестовой заглушки вы бы использовали для имитации  взаимодействия с внешним API или базой данных?


Ответы - Задание 1

Использование тестовых заглушек (или моков) полезно при написании модульных тестов по нескольким причинам:

Упрощение изоляции модулей: Заглушки позволяют изолировать модуль, который вы хотите протестировать, от его зависимостей. Это позволяет сосредоточиться на тестируемом модуле, а не на внешних компонентах.
Контроль поведения: С помощью заглушек вы можете управлять тем, какие значения возвращаются или какие действия выполняются при вызове зависимостей. Это помогает в создании сценариев тестирования различных ситуаций.
Ускорение тестов: Заглушки могут быть более быстрыми и предсказуемыми, чем реальные зависимости, что ускоряет выполнение модульных тестов.
Для проверки, что метод был вызван с определенными аргументами, вы можете использовать заглушки типа "шпиона" (spy). Шпионские заглушки записывают информацию о вызовах метода, включая переданные аргументы. Это позволяет вам в дальнейшем проверить, что метод был вызван с ожидаемыми аргументами.

Для возврата определенного значения или генерации исключения в ответ на вызов метода, вы можете использовать заглушки типа "подделки" (stub). Эти заглушки предоставляют желаемое значение или исключение при вызове метода, что позволяет вам симулировать различные сценарии и проверить, как ваш код обрабатывает их.

Для имитации взаимодействия с внешними API или базой данных следует использовать заглушки типа "моки" (mocks). Моки представляют собой имитации внешних систем, которые могут возвращать предопределенные данные или реагировать на вызовы методов, как если бы они были реальными. Это позволяет вам тестировать код, который зависит от внешних ресурсов, без реального взаимодействия с ними, что делает тесты более надежными и предсказуемыми.